# coding: utf-8

"""
    HashiCorp Vault API

    HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.  # noqa: E501

    OpenAPI spec version: 1.2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class Body19(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'force': 'bool',
        'from_entity_ids': 'list[str]',
        'to_entity_id': 'str'
    }

    attribute_map = {
        'force': 'force',
        'from_entity_ids': 'from_entity_ids',
        'to_entity_id': 'to_entity_id'
    }

    def __init__(self, force=None, from_entity_ids=None, to_entity_id=None):  # noqa: E501
        """Body19 - a model defined in Swagger"""  # noqa: E501
        self._force = None
        self._from_entity_ids = None
        self._to_entity_id = None
        self.discriminator = None
        if force is not None:
            self.force = force
        if from_entity_ids is not None:
            self.from_entity_ids = from_entity_ids
        if to_entity_id is not None:
            self.to_entity_id = to_entity_id

    @property
    def force(self):
        """Gets the force of this Body19.  # noqa: E501

        Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts.  # noqa: E501

        :return: The force of this Body19.  # noqa: E501
        :rtype: bool
        """
        return self._force

    @force.setter
    def force(self, force):
        """Sets the force of this Body19.

        Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts.  # noqa: E501

        :param force: The force of this Body19.  # noqa: E501
        :type: bool
        """

        self._force = force

    @property
    def from_entity_ids(self):
        """Gets the from_entity_ids of this Body19.  # noqa: E501

        Entity IDs which needs to get merged  # noqa: E501

        :return: The from_entity_ids of this Body19.  # noqa: E501
        :rtype: list[str]
        """
        return self._from_entity_ids

    @from_entity_ids.setter
    def from_entity_ids(self, from_entity_ids):
        """Sets the from_entity_ids of this Body19.

        Entity IDs which needs to get merged  # noqa: E501

        :param from_entity_ids: The from_entity_ids of this Body19.  # noqa: E501
        :type: list[str]
        """

        self._from_entity_ids = from_entity_ids

    @property
    def to_entity_id(self):
        """Gets the to_entity_id of this Body19.  # noqa: E501

        Entity ID into which all the other entities need to get merged  # noqa: E501

        :return: The to_entity_id of this Body19.  # noqa: E501
        :rtype: str
        """
        return self._to_entity_id

    @to_entity_id.setter
    def to_entity_id(self, to_entity_id):
        """Sets the to_entity_id of this Body19.

        Entity ID into which all the other entities need to get merged  # noqa: E501

        :param to_entity_id: The to_entity_id of this Body19.  # noqa: E501
        :type: str
        """

        self._to_entity_id = to_entity_id

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Body19, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Body19):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
